% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logitbcfBMA.R
\name{logitbcfBMA}
\alias{logitbcfBMA}
\title{Logit Bayesian Causal Forest Using Bayesian Model Averaging (Logit-BCF-BMA)}
\usage{
logitbcfBMA(
  x.train,
  y.train,
  z,
  pihat,
  a_mu = 3,
  a_tau = 3,
  nu = 3,
  sigquant = 0.9,
  c = 1000,
  pen_mu = 12,
  pen_tau = 12,
  num_cp_mu = 20,
  num_cp_tau = 20,
  x.test = matrix(0, 0, 0),
  test_z = numeric(),
  test_pihat = matrix(0, 0, 0),
  ntree_control = 5,
  ntree_moderate = 5,
  alpha_mu = 0.95,
  alpha_tau = 0.95,
  beta_mu = 1,
  beta_tau = 1,
  split_rule_node = 0,
  gridpoint = 0,
  maxOWsize = 100,
  num_splits_mu = 5,
  num_splits_tau = 5,
  gridsize_mu = 10,
  gridsize_tau = 10,
  include_pi = "control",
  zero_split = 1,
  only_max_num_trees = 1,
  mu_or_tau_each_round = 1,
  separate_tree_numbers = 1,
  min_num_obs_for_mu_split = 2,
  min_num_obs_after_mu_split = 2,
  min_num_obs_for_tau_split = 2,
  min_num_obs_after_tau_split = 2,
  exact_residuals = 1,
  spike_tree = 0,
  s_t_hyperprior = 1,
  p_s_t_mu = 0.5,
  a_s_t_mu = 1,
  b_s_t_mu = 3,
  p_s_t_tau = 0.5,
  a_s_t_tau = 1,
  b_s_t_tau = 3,
  lambda_poisson_mu = 10,
  lambda_poisson_tau = 10,
  transform_resids = 0,
  include_cate_intervals = 1,
  ncores = 1,
  root_alg_precision = 1e-05,
  maxit = 300,
  eps_f = 1e-08,
  eps_g = 1e-05,
  lower_prob = 0.025,
  upper_prob = 0.975,
  num_iter = 1000
)
}
\arguments{
\item{x.train}{Training data covariate matrix excluding the treatment and propensity scores.}

\item{y.train}{Training data outcome vector.}

\item{z}{Training data treatment vector. This should be a binary vector, equal to one for treated individuals.}

\item{pihat}{Training data propensity score estimates. Each column should be a vector of propensity score estimates.}

\item{a_mu}{This is a parameter that influences the variance of the terminal node values for trees that are not interacted with the treatment.}

\item{a_tau}{This is a parameter that influences the variance of the terminal node values for trees that are interacted with the treatment.}

\item{nu}{This is a hyperparameter in the distribution of the variance of the error term. THe inverse of the variance is distributed as Gamma (nu/2, nu*lambda/2).}

\item{sigquant}{??}

\item{c}{This determines the size of Occam's Window}

\item{pen_mu}{This is a parameter used by the Pruned Exact Linear Time Algorithm when finding changepoints for mu trees.}

\item{pen_tau}{This is a parameter used by the Pruned Exact Linear Time Algorithm when finding changepoints for tau trees.}

\item{num_cp_mu}{This is a number between 0 and 100 that determines the proportion of changepoints proposed by the changepoint detection algorithm to keep when growing mu trees.}

\item{num_cp_tau}{This is a number between 0 and 100 that determines the proportion of changepoints proposed by the changepoint detection algorithm to keep when growing tau trees.}

\item{x.test}{Test data covariate matrix excluding the treatment and propensity scores.}

\item{test_z}{Test data treatment vector. This should be a binary vector, equal to one for treated individuals.}

\item{test_pihat}{Test data propensity score estimates. Each column should be a vector of propensity score estimates.}

\item{ntree_control}{Number of trees that are not interacteds with the treatment.}

\item{ntree_moderate}{Number of trees that are interacted with the treatment.}

\item{alpha_mu}{Parameter in prior probability of tree node splitting.}

\item{alpha_tau}{Parameter in prior probability of tree node splitting.}

\item{beta_mu}{Parameter in prior probability of tree node splitting.}

\item{beta_tau}{Parameter in prior probability of tree node splitting.}

\item{split_rule_node}{Binary variable. If equals 1, then find a new set of potential splitting points via a changepoint algorithm after adding each split to a tree. If equals zero, use the same set of potential split points for all splits in a tree.}

\item{gridpoint}{Binary variable. If equals 1, then a grid search changepoint detection algorithm will be used. If equals 0, then the Pruned Exact Linear Time (PELT) changepoint detection algorithm will be used (Killick et al. 2012).}

\item{maxOWsize}{Maximum number of models to keep in Occam's window}

\item{num_splits_mu}{Maximum number of splits in a mu tree}

\item{num_splits_tau}{Maximum number of splits in a tau tree}

\item{gridsize_mu}{This integer determines the size of the grid across which to search if gridpoint=1 when constructing mu trees.}

\item{gridsize_tau}{This integer determines the size of the grid across which to search if gridpoint=1 when constructing tau trees.}

\item{include_pi}{Takes values "control", "moderate", "both" or "none". Whether to include pihat in mu(x) ("control"), tau(x) ("moderate"), both or none. Values of "control" or "both" are HIGHLY recommended with observational data.}

\item{zero_split}{Binary variable. If equals 1, then zero split trees can be included in a sum-of-trees model. If equals zero, then only trees with at least one split can be included in a sum-of-trees model.}

\item{only_max_num_trees}{Binary variable. If equals 1, then only sum-of-trees models containing the maximum number of trees, num_rounds, are selected. If equals 0, then sum-of-trees models containing less than num_rounds trees can be selected. The default is only_max_num_trees=1.}

\item{mu_or_tau_each_round}{Binary variable. If equals 1, then a mu tree or a tau tree is added in each round. If equals 0, then a mu tree is added, followed by a tau tree, followed by a mu tree, and so on.}

\item{separate_tree_numbers}{Binary variable (irrelevant if mu_or_tau_each_round not equal to 1). If equals 1, and mu_or_tau_each_round equals 1, then num_splits_mu and num_splits_tau are the maximum numbers of mu and tau trees in the model. If equals zero, and mu_or_tau_each_round equals 1, then num_splits_mu + num_splits_tau is the maximum total number of trees, but there are not separate limits to the number of mu and tau trees.}

\item{min_num_obs_for_mu_split}{This integer determines the minimum number of observations in a (parent) mu tree node for the algorithm to consider potential splits of the node.}

\item{min_num_obs_after_mu_split}{This integer determines the minimum number of observations in a (mu tree) child node resulting from a split in order for a split to occur. If the left or right child node has less than this number of observations, then the split can not occur.}

\item{min_num_obs_for_tau_split}{This integer determines the minimum number of treated observations in a (parent) tau tree node for the algorithm to consider potential splits of the node.}

\item{min_num_obs_after_tau_split}{This integer determines the minimum number of treated observations in a (tau tree) child node resulting from a split in order for a split to occur. If the left or right child node has less than this number of observations, then the split can not occur.}

\item{exact_residuals}{Binary variable. If equal to 1, then trees are added to sum-of-tree models within each round of the algorithm by detecting changepoints in the exact residuals. If equals zero, then changepoints are detected in residuals that are constructed from approximate predictions.}

\item{transform_resids}{Binary variable. If equal to 1, then a Horvitz-Thompson transformation is applied to residuals before finding chanegpoints for building tau trees.}
}
\value{
The following objects are returned by bcfbma:
\item{fitted.values_outcome}{The vector of predictions of the outcome for all training observations.}
\item{fitted.values_mu}{The vector of fiited values of mu(x) for all training observations.}
\item{fitted.values_tau}{The vector of fiited values of tau(x) for all training observations. These are the in-sample ITE estimates.}
\item{sumoftrees_mu}{This is a list of lists of matrices. The outer list corresponds to a list of sum-of-tree models, and each element of the outer list is a list of matrices describing the structure of the mu(x) trees within a sum-of-tree model. See details.}
\item{sumoftrees_tau}{This is a list of lists of matrices. The outer list corresponds to a list of sum-of-tree models, and each element of the outer list is a list of matrices describing the structure of the tau(x) trees within a sum-of-tree model. See details.}
\item{obs_to_termNodesMatrix_mu}{This is a list of lists of matrices. The outer list corresponds to a list of sum-of-tree models, and each element of the outer list is a list of matrices describing to which node each of the observations is allocated to at all depths of each mu(x) trees within a sum-of-tree model. See details.}
\item{obs_to_termNodesMatrix_tau}{This is a list of lists of matrices. The outer list corresponds to a list of sum-of-tree models, and each element of the outer list is a list of matrices describing to which node each of the observations is allocated to at all depths of each tau(x) trees within a sum-of-tree model. See details.}
\item{bic}{This is a vector of BICs for each sum-of-tree model.}
\item{sum_residuals_mu}{A list of lists (if more than one mu(x) tree) of vectors of partial residuals for each tree in mu(x) in each model.}
\item{sum_residuals_tau}{A list of lists (if more than one tau(x) tree) of vectors of partial residuals for each tree in tau(x) in each model.}
\item{numvars}{This is the total number of variables in the input training data matrix, excluding the pihat matrix.}
\item{call}{match.call returns a call in which all of the specified arguments are specified by their full names.}
\item{y_minmax}{Range of the input training data outcome vector.}
\item{response}{Input taining data outcome vector.}
\item{nrowTrain}{number of observations in the input training data.}
\item{sigma}{sd(y.train)/(max(y.train)-min(y.train))}
\item{a_mu}{input parameter}
\item{a_tau}{input parameter}
\item{nu}{input parameter}
\item{lambda}{parameter determined by the inputs sigma, sigquant, and nu}
\item{numPSmethods}{Number of columns of the input matrix pihat. This should be the number of different propoensity score estimates used.}
\item{include_pi2}{Equals 0 if input parameter include_pi is control, 1 if moderate, 2 if both, 4 if none.}
\item{z}{Input training data treatment vector. This should be a binary vector, equal to one for treated individuals.}
}
\description{
BCF-BMA for binary outcomes. Averages over logistic functions of sums-of-trees.
The outcome is modelled as mu(x)+Z*tau(x), where mu(x) and tau(x) are sums-of-trees and Z is a treatment indicator variable. Therefore tau(x) gives the Individual Treatment Effect (ITE) estimates.
}
